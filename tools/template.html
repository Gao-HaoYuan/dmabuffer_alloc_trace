<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Visulization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* loading style. */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        .loading {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 2s linear infinite;
        }
        /* tips style*/
        .dropdown {
            position: relative;
            display: inline-block;
        }
        #dropdownBtn {
            background-color: #3498db;
            color: #fff;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease;
        }
        #dropdownBtn:hover {
            background-color: #2c85c7;
        }
        .myPopup {
            display: none;
            position: absolute;
            top: 50px;
            left: 50%;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            width: 500px;
            z-index: 999;
        }
        .myPopup p {
            margin: 0 0 15px 0;
        }
        .myPopup ul {
            list-style-type: disc;
            padding-left: 20px;
        }
        #closeBtn {
            background-color: #e74c3c;
            color: #fff;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            margin-top: 10px;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease;
        }
        #closeBtn:hover {
            background-color: #c9302c;
        }
        /* tooltip style */
        .bar-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 999;
        }
        /* memory style */
        .center-container {
            margin-top: 1%;
            display: flex;
            justify-content: center;
            align-items: start;
        }
        .chart-title {
            position: absolute;
            top: 0;
            left: 50%; /* Horizontally center the title */
        }
        .charts-container {
            display: flex;
            overflow-x: auto;
            white-space: nowrap;
            width: 100%;
        }
        .mempeak {
            position: absolute;
            display: none;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
            white-space: nowrap;
            z-index: 999;
        }
        /* time select */
        .time-selector-container {
            position: absolute;
            left: 8%;
            top: 100px;
            display: inline-block;
            transform: scaleY(-1);
            writing-mode: vertical-lr;
            z-index: 3;
        }
        input[type="range"] {
            height: 600px;
        }
        #peak-indicator {
            position: absolute;
            left: 19%;
            width: 8px;
            height: 8px;
            background-color: red;
            border-radius: 50%;
            z-index: 2;
        }
        .time-selector-label {
            position: absolute;
            font-size: 15px;
            font-weight: bold;
            color: #333;
            left: 6%;
            top: 700px;
        }
    </style>
</head>
<body>

<!-- loading... -->
<div class="loading-container" id="loading-container">
    <div class="loading"></div>
    <p>Loading...</p>
</div>

<div class="content" id="content" style="display: none;">
    <!-- tips -->
    <div class="dropdown">
        <button id="dropdownBtn"> Tips </button>
        <div id="myPopup" class="myPopup">
            <p>使用技巧:</p>
            <ul>
                <li>当鼠标悬停在内存块上时, 显示内存块信息</li>
                <li>鼠标左击内存块, 显示堆栈信息</li>
                <li>鼠标悬停在“内存峰值分布图”上时, 显示内存峰值</li>
                <li>x 轴表示当前时刻的内存分布及持续时间</li>
                <li>鼠标左键点击或滑动 time selector, 可以显示不同时刻的内存分布</li>
            </ul>
            <p>常见问题:</p>
            <ul>
                <li>堆栈展开时没有符号, 只有地址</li>
                    <ol>                    
                        <li> 用带符号表的文件进行抓 trace</li>
                        <li> 如果用 strip 后的库的话， 编译时请去掉 --version-script </li>
                    </ol>
            </ul>
            <button id="closeBtn">关闭</button>
        </div>
    </div>

    <!-- time select -->
    <div class="time-selector-container">
        <div id="peak-indicator"></div>
        <input type="range" id="time-selector" step="1" value="50" oninput="updateTime()">
    </div>
    <label for="time-selector" class="time-selector-label">Time Selector</label>
    
    <!-- tooltip -->
    <div class="bar-tooltip" id="tooltip"></div>

    <!-- memory -->
    <div class="center-container">
        <div class="chart-title">
            <h4 onmouseover="showMemPeak()" onmouseout="hideMemPeak()">内存分布图</h4>
            <span id="mempeak" class="mempeak"></span>
        </div>
        <div class="y-axis-container">
            <svg width="100" height="800"><g class="y-axis"></g></svg>
        </div>
        <div class="chart-x-axis-container">
            <div class="chart-container" id="charts-container"></div>
            <div class="x-axis-container">
                <svg width="1300" height="30"><g class="x-axis"></g></svg>
            </div>
        </div>
    </div>
</div>

<!-- JavaScript -->
<script>
    var tooltip = d3.select("#tooltip");
    var lastElement = null;
	var originColor;
    var contextWidth = 1300;
    var contextHeight = 800;
    var traceData = [];
    var timeSelector = document.getElementById('time-selector');
    function updateChart(data, container, yScale, xScale, xStart) {
        const svg = container.append("svg")
			.attr("width", contextWidth)
			.attr("height", contextHeight);
        var currentY = 0;
        svg.selectAll("rect")
            .data(data.reverse())
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", function(d) { return xScale(d.mallocTime - xStart); })
            .attr("y", d => {
				const y = currentY;
				currentY += yScale(d.size);
				return y;
			})
            .attr("width", function(d) { return xScale(d.freeTime - xStart) - xScale(d.mallocTime - xStart); })
            .attr("height", d => yScale(d.size))
            .attr("fill", (d, i) => i % 2 === 0 ? "#6DC8F1" : "lightgreen")
            .on("mouseover", createTooltip)
            .on("mouseout", function () {
				tooltip.style("display", "none");
			})
            .on("click", function(event){
                if(lastElement){
                    alert("请关闭backtrace窗口!!");
                }
                else{
                    // add mouse click to open popup window
                    event.preventDefault();
                    if(lastElement){
                        lastElement.style.fill = originColor;
                    }
                    const targetElement = event.target; // get mouse click event
                    const computedStyle = window.getComputedStyle(targetElement);
                    originColor = computedStyle.getPropertyValue('fill');
                    var data = d3.select(targetElement).data()[0];
                    if (data.stack.length > 0) {
                        targetElement.style.fill = "orange";
                        const popup = createPopupWindow(0, 0, data.stack);
                        lastElement = targetElement;
                        popup.addEventListener("beforeunload", function () {
                            targetElement.style.fill = originColor;
                            lastElement = null;
                        });
                    }
                }
            });
    }
    // function to fiter data
    function filterdata (peakTime, traceData) {
        document.getElementById('charts-container').innerHTML = '';
        var filteredData = traceData.filter(function(item) {
            return item.mallocTime <= peakTime && item.freeTime >= peakTime;
        });
        var xStart = d3.min(filteredData, function(d) { return d.mallocTime; });
        var xEnd = d3.max(filteredData, function(d) { return d.freeTime; });
        var memPeak = d3.sum(filteredData, d => d.size);

        var container = d3.select("#charts-container");
        const yScale = d3.scaleLinear()
			.domain([0, memPeak])
			.range([0, contextHeight]);
        var xScale = d3.scaleLinear()
            .domain([0, xEnd - xStart])
            .range([0, contextWidth]);
        // add y axis
        const yAxis = d3.axisLeft(yScale)
            .ticks(7)
            .tickFormat(d => ((memPeak - d) / 1024).toFixed(1) + "KB");
        const yAxisGroup = d3.select('.y-axis')
            .call(yAxis)
            .attr('transform', `translate(90, 4)`);
        // add x axis
        const xAxis = d3.axisBottom(xScale)
            .ticks(15)
            .tickFormat(d => (d / 1000).toFixed(0) + "ms");
        const xAxisGroup = d3.select('.x-axis')
            .call(xAxis)
            .attr('transform', `translate(9, 0)`);
        updateChart(filteredData, container, yScale, xScale, xStart);

        const memoryPeak = document.getElementById("mempeak");
        memoryPeak.textContent = "内存峰值为: " + (memPeak / 1024).toFixed(2) + "KB";
        document.getElementById('content').style.display = 'block';
    }
	// Function to show mempeak content
	function showMemPeak() {
		const memoryPeak = document.getElementById("mempeak");
		memoryPeak.style.display = "block";
	}
	// Function to hide mempeak content
	function hideMemPeak() {
		const memoryPeak = document.getElementById("mempeak");
		memoryPeak.style.display = "none";
	}
    // show tooltip
    function createTooltip () {
		const d = d3.select(this).data()[0];
		const mouseX = event.clientX;
		const mouseY = event.clientY + window.scrollY;
		let tooltipX = mouseX;
		let tooltipY = mouseY;

		var tooltipContent = "<strong>Size:</strong> " + 
                (d.size / 1024).toFixed(1) + "KB" + "<br><strong>Duration:</strong> " + (d.freeTime - d.mallocTime) / 1000 + "ms";
		tooltip.style("left", tooltipX + "px");
		tooltip.style("top", tooltipY + "px");
		tooltip.style("display", "block");
		tooltip.html(tooltipContent);
	}
    // create popup window
    function createPopupWindow(x, y, d) {
		const width = 800;
		const height = 700;
		const left = x;
		const top = y;
		const popup = window.open("", "PopupWindow", `width=${width}, height=${height}, left=${left}, top=${top}`);
		popup.document.body.innerHTML = "";
        var extractedData = d.map(function(line) {
            var match = line.match(/#(\d+)\s+pc\s+([0-9a-fA-F]+)\s+(.*?) \((.*?)\+(\d+)\)/);
            if (match) {
                return {
                    id: match[1],
                    address: match[2],
                    library: match[3],
                    function: match[4]
                };
            } else {
                return null;
            }
        });
		popup.document.write("<strong>Backtrace:</strong><ul>");
		extractedData.forEach(function (trace) {
			popup.document.write("<li><strong>ID:</strong> " + trace.id + "<br><strong>Address:</strong> 0x" +trace.address + "<br><strong>Library:</strong> " + trace.library + "<br><strong>Function:</strong> " + trace.function + "</li><br>");
		});
		popup.document.write("</ul>");
		return popup;
	}
    // control tips
    const dropdownBtn = document.getElementById("dropdownBtn");
    const myPopup = document.getElementById("myPopup");
    const closeBtn = document.getElementById("closeBtn");

    dropdownBtn.addEventListener("click", function () {
        myPopup.style.display = "block";
    });

    closeBtn.addEventListener("click", function () {
        myPopup.style.display = "none";
    });
    // time selector
    function updateTime() {
        timeSelector.addEventListener("mouseup", function(event) {
        if (event.button === 0) {
            const selectTime = timeSelector.value;
            filterdata(selectTime, traceData);
        }
    });
    }
    // load code
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('loading-container').style.display = 'block';
        var traceScript = document.querySelector('script.trace');
        if (!traceScript) {
            console.error('找不到匹配的 <script> 标签。');
            return;
        }
        
        var traceText = traceScript.textContent;
        var lines = traceText.trim().split('\n');
        var entry = null;
        var flag = false;
        var peakTime = 0;
        var minMallocTime = Infinity;
        var maxFreeTime = -Infinity;
        lines.forEach(function(line) {
            var trimmedLine = line.trim();
            if (trimmedLine.startsWith("S")) {
                var matches = trimmedLine.match(/^S(\d+)\s+A(\d+)\s+F(\d+)\s*$/);
                if (matches) {
                    var size = parseInt(matches[1]);
                    flag = matches[3] !== '0' && size > 1023; // update flag
                    if (flag) {
                        entry = {
                            size: size,
                            mallocTime: parseInt(matches[2]),
                            freeTime: parseInt(matches[3]),
                            stack: [] // init stack
                        };
                        minMallocTime = Math.min(minMallocTime, entry.mallocTime);
                        maxFreeTime = Math.max(maxFreeTime, entry.freeTime);
                    }
                } else {
                    console.error("Failed to match line:", line);
                }
            } else if (trimmedLine.startsWith("#") && flag) {
                entry.stack.push(trimmedLine);
            } else if (trimmedLine === "" && flag) {
                traceData.push(entry);
            }
            else if (trimmedLine.startsWith("P")) {
                var matches = trimmedLine.match(/^p(\d+)/i);
                if (matches) {
                    peakTime = parseInt(matches[1]);
                } else {
                    console.error("Failed to match number after 'p'");
                }
                
            }
        });
        // update time select
        const peakIndicator = document.getElementById('peak-indicator');
        timeSelector.min = minMallocTime;
        timeSelector.max = maxFreeTime;
        timeSelector.value = peakTime;
        const range = maxFreeTime - minMallocTime;
        const percent = (peakTime - minMallocTime) / range;
        const indicatorPosition =  600*percent;
        peakIndicator.style.top = `${indicatorPosition}px`;
        // update chart
        filterdata(peakTime, traceData);
        document.getElementById('loading-container').style.display = 'none';
    });
</script>

<!-- backtrace info -->
<script class="trace" type="application/text">